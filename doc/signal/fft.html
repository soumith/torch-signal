<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L60">[src]</a>
<a name="signal.fft"></a></p>

<h3>signal.fft(input)</h3>

<p>1D FFT
   Takes Real inputs (1D tensor of N points)
   or complex inputs 2D tensor of (Nx2) size for N points</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L71">[src]</a>
<a name="signal.ifft"></a></p>

<h3>signal.ifft(input)</h3>

<p>inverse 1D FFT
   Takes Real inputs (1D tensor of N points)
   or complex inputs 2D tensor of (Nx2) size for N points</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L81">[src]</a>
<a name="signal.rfft"></a></p>

<h3>signal.rfft(input)</h3>

<p>real to complex dft.
   This function retains only the positive frequencies.
   Input is a 1D real tensor
   Output is 2D complex tensor of size (input:size(1)/2 + 1, 2)</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L101">[src]</a>
<a name="signal.irfft"></a></p>

<h3>signal.irfft(input)</h3>

<p>complex to real dft. This function is the exact inverse of signal.rfft</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L158">[src]</a>
<a name="signal.fft2"></a></p>

<h3>signal.fft2(input)</h3>

<p>2D FFT
   Takes Real inputs (2D tensor of NxM points)
   or complex inputs 3D tensor of (NxMx2) size for NxM points</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L169">[src]</a>
<a name="signal.ifft2"></a></p>

<h3>signal.ifft2(input)</h3>

<p>2D Inverse FFT
   Takes Real inputs (2D tensor of NxM points)
   or complex inputs 3D tensor of (NxMx2) size for NxM points</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L211">[src]</a>
<a name="signal.fft3"></a></p>

<h3>signal.fft3(input)</h3>

<p>3D FFT
   Takes Real inputs (3D tensor of NxMxP points)
   or complex inputs 4D tensor of (NxMxPx2) size for NxMxP points</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L222">[src]</a>
<a name="signal.ifft3"></a></p>

<h3>signal.ifft3(input)</h3>

<p>3D Inverse FFT
   Takes Real inputs (3D tensor of NxMxP points)
   or complex inputs 4D tensor of (NxMxPx2) size for NxMxP points</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L233">[src]</a>
<a name="signal.hann"></a></p>

<h3>signal.hann(L, flag)</h3>

<p>returns an L-point Hann window in a 1D tensor. L must be a positive integer.
   When &#39;periodic&#39; is specified, hann computes a length L+1 window and returns the first L points.
   flag: &#39;periodic&#39; or &#39;symmetric&#39;. &#39;symmetric&#39; is default</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L259">[src]</a>
<a name="signal.blackman"></a></p>

<h3>signal.blackman(N, flag)</h3>

<p>returns an N-point Blackman window in a 1D tensor. 
   N must be a positive integer.
   When &#39;periodic&#39; is specified, computes a length N+1 window and returns the first N points.
   flag: &#39;periodic&#39; or &#39;symmetric&#39;. &#39;symmetric&#39; is default</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L300">[src]</a>
<a name="signal.blackmanharris"></a></p>

<h3>signal.blackmanharris(N, flag)</h3>

<p>returns an N-point minimum 4-term Blackman-Harris window in a 1D tensor. 
   The window is minimum in the sense that its maximum sidelobes are minimized.
   N must be a positive integer.<br>
   flag: &#39;periodic&#39; or &#39;symmetric&#39;. &#39;symmetric&#39; is default</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L354">[src]</a>
<a name="signal.stft"></a></p>

<h3>signal.stft(input, window_size, window_stride, window_type)</h3>

<p>1D complex short-time fourier transforms
   Run a window across your signal and calculate fourier transforms on that window.
   To make sure that the windows are not discontinuous at the edges, you can optionally apply a window preprocessor.
   The available window preprocessors are: hamming, hann, bartlett</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L382">[src]</a>
<a name="signal.rstft"></a></p>

<h3>signal.rstft(input, window_size, window_stride, window_type)</h3>

<p>1D real short-time fourier transforms
   Run a window across your signal and calculate fourier transforms on that window.
   To make sure that the windows are not discontinuous at the edges, you can optionally apply a window preprocessor.
   rfft is used for fourier transform, so only the positive frequencies are retained
   The available window preprocessors are: hamming, hann, bartlett</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L408">[src]</a>
<a name="signal.spectrogram"></a></p>

<h3>signal.spectrogram(inp, window_size, window_stride)</h3>

<p>Takes the rstft(x) and generates a pretty spectrogram by
   taking the magnitude of the stft, and applying a (natural log * 10)
   Also transposes the output, to have time on the X axis.</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L431">[src]</a>
<a name="signal.unwrap"></a></p>

<h3>signal.unwrap(a, tol)</h3>

<p>Correct phase angles to produce smoother phase plots<br>
   Unwrap radian phases by adding multiples of 2*pi as appropriate to
   remove jumps greater than <strong>tol</strong>. <strong>tol</strong> defaults to pi.   </p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L458">[src]</a>
<a name="signal.rcunwrap"></a></p>

<h3>signal.rcunwrap(x)</h3>

<p>unwraps the phase and removes phase corresponding to integer lag.</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L477">[src]</a>
<a name="signal.rcwrap"></a></p>

<h3>signal.rcwrap(y, nd)</h3>

<p>Adds phase corresponding to integer lag</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L497">[src]</a>
<a name="signal.cceps"></a></p>

<h3>signal.cceps(x)</h3>

<p>1D Complex cepstral analysis
   Returns the cepstrum and a phase shift factor &quot;nd&quot; that is useful to invert the signal back.</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L521">[src]</a>
<a name="signal.icceps"></a></p>

<h3>signal.icceps(xhat,nd)</h3>

<p>1D Inverse Complex cepstral analysis.
   Takes in the outputs of cceps to produce the input signal back</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L539">[src]</a>
<a name="signal.rceps"></a></p>

<h3>signal.rceps(x)</h3>

<p>Real cepstrum and minimum phase reconstruction
   The real cepstrum is the inverse Fourier transform of the real logarithm of the magnitude of the Fourier transform of a sequence.</p>

<p>Output matches with matlab output</p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L578">[src]</a>
<a name="signal.dct"></a></p>

<h3>signal.dct(input)</h3>

<p>1D Discrete Cosine Transform (DCT)
   Takes Real inputs (1D tensor of N points)</p>

<p>To see what is exactly computed, see section REDFT10 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a></p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L589">[src]</a>
<a name="signal.idct"></a></p>

<h3>signal.idct(input)</h3>

<p>inverse 1D Discrete Cosine Transform (DCT)
   Takes Real inputs (1D tensor of N points)</p>

<p>To see what is exactly computed, see section REDFT01 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a></p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L626">[src]</a>
<a name="signal.dct2"></a></p>

<h3>signal.dct2(input)</h3>

<p>2D Discrete Cosine Transform (DCT)
   Takes Real inputs (2D tensor of NxM points)</p>

<p>To see what is exactly computed, see section REDFT10 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a></p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L637">[src]</a>
<a name="signal.idct2"></a></p>

<h3>signal.idct2(input)</h3>

<p>inverse 2D Discrete Cosine Transform (DCT)
   Takes Real inputs (2D tensor of NxM points)</p>

<p>To see what is exactly computed, see section REDFT01 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a></p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L676">[src]</a>
<a name="signal.dct3"></a></p>

<h3>signal.dct3(input)</h3>

<p>3D Discrete Cosine Transform (DCT)
   Takes Real inputs (3D tensor of NxMXP points)</p>

<p>To see what is exactly computed, see section REDFT10 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a></p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L687">[src]</a>
<a name="signal.idct3"></a></p>

<h3>signal.idct3(input)</h3>

<p>inverse 3D Discrete Cosine Transform (DCT)
   Takes Real inputs (3D tensor of NxMxP points)</p>

<p>To see what is exactly computed, see section REDFT01 over here: 
   <a href="http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html">http://www.fftw.org/doc/1d-Real_002deven-DFTs-_0028DCTs_0029.html</a></p>

<p><a class="entityLink" href="https://github.com/soumith/torch-signal/blob/272138111678b6da3f3a873204b4cb14aaef2e37/fft.lua#L697">[src]</a>
<a name="signal.hilbert"></a></p>

<h3>signal.hilbert(xr)</h3>

<p>Discrete-time analytic signal using Hilbert transform
   Takes 1D inputs</p>

<p>Output matches with matlab output</p>

<h4>Undocumented methods</h4>

<p><a name="signal.typecheck"></a></p>

<ul>
<li><code>signal.typecheck(input)</code></li>
</ul>
